
<!--
       * video-tagging control for video tagging
       * Main file of the video-tagging module.
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="video-taggingstyles.html">
<link rel="import" href="optional-tags.html">
<link rel="import" href="playback-control.html">

<dom-module id="video-tagging">
  <template>
    <style include="video-taggingstyles"></style>
    <link rel="stylesheet" href="css/sliders.css" />
    <link rel="stylesheet" href="css/selectiontool.css" />
    <link rel="stylesheet" href="../jquery-ui/themes/base/resizable.css">
    <link rel="stylesheet" href="css/imgareaselect-animated.css" />
    <link rel="stylesheet" href="../bootstrap/dist/css/bootstrap.min.css" />
    <link rel="stylesheet" href="assets/icons/style.css">

    <div id="controlWrapper" class="controlWrapper">
      <playback-control id="playSpeedControl" class="playSpeedControl"></playback-control>
      <div id='videoWrapper' class="relativeDiv">
            <svg id="selectionZone" class="selectionZoneStyle" >                  
                </svg>  
          <div id = "regionLabelDiv" style="width:40px;height:20px;" class="regionLabel" >
              <span id="regionLabelSpan" class="regionLabelSpan"></span>
              <span id="closeRegionImage" on-click="deleteRegion" class="closeRegion clickableControl">X</span>
          </div>
            

              <canvas id="overlay"  on-click='videoClicked' class="overlaystyle" width="100" height="100" >
                      Your browser does not support the HTML5 canvas location.
              </canvas>
              <canvas id='frameCanvas' class="frameCanvasStyle" width="100" height="100" >

              </canvas>

              <video id='vid' class="videoStyle">
                       Your browser does not support the video location.
              </video>
      </div>
      <div id="videoControls" class="videoControls">
        <input id="seekBar" class="seek clickableControl" type="range" min='0' value="0" step="any" onkeydown="return false;"  required />
          <table id="videoControlsTable" class="videoControlsTable">

            <tr>
              <td class="videoControlCell simpleControl clickableControl">
                <span id="stepbwd" title="prev" class="icon-backward2 taggingControls" on-click='stepBwdClicked'></span>
              </td>
              <td class="videoControlCell simpleControl clickableControl" style="display: none">
                <span id="play-pause" title="play/pause" class="icon-play3 taggingControls" on-click='playPauseClicked' ></span>
              </td>
              <td class="videoControlCell simpleControl clickableControl">
                <span id="stepfwd" title="next" class="icon-forward3 taggingControls" on-click='stepFwdClicked'></span>
              </td>
              <td class="videoControlCell simpleControl clickableControl">
                <span id="nextuntagged"  title="first untagged frame" class="icon-next2 taggingControls" on-click='nextUntaggedClicked'></span>
              </td>
              <td class="videoControlCell simpleControl clickableControl">
                <span id="clearRegions"  title="clear tags" class="glyphicon glyphicon-ban-circle taggingControls" on-click='clearRegions'></span>
              </td>
              <td id="rotate" class="videoControlCell simpleControl clickableControl" style="display: none">
                <span title="rotate right" class="glyphicon glyphicon-repeat taggingControls" on-click="rotate"></span>
              </td>
              <td class="videoControlCell frameNumber">
                <span id='frameText' class="textElements" title="frame#"></span>
              </td>
              <td id="playSpeedCell" title="play speed" class="videoControlCell longControl clickableControl" style="display: none">
                <span id="playbackSpan"  class="textElements" on-click="playbackSpeedClicked">x 1.0</span>
              </td>
              <td nowrap="nowrap" class="videoControlCell simpleControl">
                <span id="timeSpan" class="textElements"></span>
              </td>
              <td class ="videoControlCell simpleControl clickableControl" style="display: none">
                <span id="mute" title="Mute" class="icon-volume-medium taggingControls" on-click='muteClicked'></span>
              </td>
              <td class="volumeControlCell longControl" style="display: none">
                  <input id="volumeSlider" class="volume clickableControl" type="range" min=0 max = 1 value=.5 step= .1 required />
              </td>

            </tr>
          </table>
      </div>
      <div id="videoTagControls" class="videoTagControls">
          <div class="optionalTags">
            <div class="optionalTagsWrapper">
              <optional-tags id="optionalTags"></optional-tags>
            </div>
          </div>
          <div class="labelControls">
              <span id="emptyFrame" title="empty frame"  class="icon-share taggingControls controlOff" on-click='emptyFrameClicked' ></span>
              <span id="lockTag" title="lock tags" class="icon-pushpin taggingControls lockTag controlOff"  on-click='lockTagsClicked' ></span>
          </div>
          <div style="clear: both">
          </div>
      </div>
</div>
</template>
<script>

  
  Polymer({
    is: 'video-tagging',
    properties: {
      framerate: Number,
      videoduration: Number,
      videowidth: Number,
      videoheight: Number,
      regiontype: String,
      multiregions: Number,
      regionsize: Number,
      imagelist: Object,
      inputtagsarray:Object,
      inputframes: Object,
      src: {
        type: String,
        value: '',
        observer: 'videoSrcChanged'
      }
    },
    // Element Lifecycle
    ready: function() {
        this.frames = {}; // Holds the data of the tagged frames, their regions and tags
        this.seeking = false;//Flag for enabling control over the seek bar while the video is playing, see playingCallback function
        this.selectedRegionId = 0;//Holds the current selected region number
        this.lockTagsEnabled = false;
        this.selectedTags = [];
        this.uniqueTagId = 0;
        this.videoStartTime = 0; //sometimes videos don't load at absoultue zero
        this.canMove = true;
        this.imageIndex = 0;
        this.curImg = new Image();
        this.rotation = 0;

        //Frame view size
        this.frameWidth = 0;
        this.frameHeight = 0;

        //Divs and spans
        this.controlWrapper= this.$$('#controlWrapper');
        this.videoWrapper= this.$$('#videoWrapper');
        this.overlay = this.$$('#overlay');
        this.video= this.$$('#vid');
        this.frameCanvas = this.$$('#frameCanvas');

        this.optionalTags= this.$$('#optionalTags');
        this.regionLabelDiv = this.$$('#regionLabelDiv');
        this.regionLabelSpan = this.$$('#regionLabelSpan');
        this.timeSpan = this.$$('#timeSpan');
        this.frameText = this.$$("#frameText");
        this.playbackSpan = this.$$("#playbackSpan");

        // Buttons
        this.playButton = this.$$('#play-pause');
        this.stepfwd = this.$$("#stepfwd");
        this.stepbwd = this.$$("#stepbwd");
        this.lockTag = this.$$("#lockTag");
        this.playSpeedControl = this.$$("#playSpeedControl");
        this.playSpeedCell = this.$$("#playSpeedCell");
        this.mute = this.$$('#mute');
        this.emptyFrame = this.$$("#emptyFrame");
        this.nextuntagged = this.$$("#nextuntagged");
        // Sliders
        this.seekBar = this.$$("#seekBar");
        this.volumeSlider = this.$$("#volumeSlider");
        //dynamic styles for sliders
        this.volumeStyle = document.createElement('style');
        Polymer.dom(this.root).appendChild(this.volumeStyle);
        this.seekStyle = document.createElement('style');
        Polymer.dom(this.root).appendChild(this.seekStyle);
        this.playing = null;
        this.ctx = this.overlay.getContext("2d");
        this.aspect = 0;
        this.snapWidth = 0;

      // svg canvas
        let self = this;
        this.selectionZone = document.getElementById("selectionZone");

        SystemJS.import("./public/js/video-tagging/js/canvastools.js").then(function(module){
            Promise.all([
                System.import('selectiontool'),
                //System.import('regiontool'),
            ]).then(function(modules){
                //var rtools = modules[1].CanvasTools.Region;
                var stools = modules[0].CanvasTools.Selection;
                
                self.areaSelector = new stools.AreaSelector(self.selectionZone, 
                    function(){
                    self.selectionZone.style.zIndex = 300;
                },
                function(x1, y1, x2, y2){
                    self.selectionZone.style.zIndex = 30;
                    self.onNewAreaSelected(x1, y1, x2, y2);
                }
                );
            });

        })
        
/*         this.selectionZone = document.getElementById("selectionZone");
        var self = this;
        this.areaSelector = AreaSelector.init(this.selectionZone, 
            function(){
                self.selectionZone.style.zIndex = 300;
            },
            function(x1, y1, x2, y2){
                self.selectionZone.style.zIndex = 30;
                self.onNewAreaSelected(x1, y1, x2, y2);
            }); */

    },
     /**
       * Events registration and handling
       *
       * @method attached
       * Events registration and handling
       */
    attached: function() {
      //Reset all variables to new src
      this.video.addEventListener( "loadedmetadata", init);
      var self = this;
      
      function init() {
            self.controlWrapper.style.display = "grid";
            //Init variables and controls
            self.frames = self.inputframes? self.inputframes:{};
            self.frameTime = 1/self.framerate;
            self.enableAreaSelect(self);
            self.optionalTags.createTagControls(self.inputtagsarray);
            //Take the raw video aspect ratio
            self.aspect = self.video.videoWidth / self.video.videoHeight;
            //self.snapToAspectRatio();
            //Init sliders
            self.volumeSlider.value = 0.5;
            self.seekBar.max = self.video.duration;            

            // Update frame size to video size     
            self.resetLayout();                          
            //self.resizeFrameSize(self.video.offsetWidth, self.video.offsetHeight);
            let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
            self.resizeFrame(scaleByPortrait, self.aspect);         

            self.playingCallback();   

            //fix resize bug
            $(window).off("resize");
            $(window).resize( function(){
                if (self.video.offsetWidth !== undefined){
                    //self.snapToAspectRatio();
                    // Update frame size to video size  
                    self.resetLayout();                  
                    
                    //self.resizeFrameSize(self.video.offsetWidth, self.video.offsetHeight);

                    let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
                    self.resizeFrame(scaleByPortrait, self.aspect);

                    //resize the region boxes
                    self.showAllRegions();
                    //reposition selectedRegion Label
                    var selectedDiv = $('.regionCanvasSelected')[0];
                    self.positionRegionNameLabel(selectedDiv);
                }
            });

            //bind keys (note this currently overrides any listener on the parent controls needs a more elegant way to work only when control is in focus)
            window.addEventListener("keyup", (function(canMove) {
                return function(e) {
                    if (!canMove) return false;
                    canMove = false;
                    setTimeout(function() { canMove = true; }, 100);
                    switch (e.keyCode) {
                        case 37:  // left
                        self.stepBwdClicked();
                        break;
                        case 39: // right
                        self.stepFwdClicked();
                        break;
                        case 46: //delete
                        case 8:  //backspace
                        if($('.regionCanvasSelected')[0]){
                            self.deleteRegion();
                        }
                        break;
                        default: return; // exit this handler for other keys
                    }
                    e.preventDefault(); // prevent the default action (scroll / move caret)
                };
            })(true), false);
      }
      this.video.onended = function(){
           self.pauseState();
      };
      this.seekBar.addEventListener("mousedown", function() {
            self.seeking = true;
          });
      this.seekBar.addEventListener("mouseup", function() {
            self.seeking = false;
          });
      this.seekBar.addEventListener("change", function() {
            if (!this.imagelist){
                 self.seeking = false;
                 self.video.currentTime =  Math.floor(self.seekBar.value/self.frameTime) * self.frameTime;//keep the frame in sync
            }
            self.playingCallback();
          });
      this.volumeSlider.addEventListener("change", function() {
            if (!this.imagelist){
                self.video.volume = self.volumeSlider.value;
                var perc =  100 * self.volumeSlider.value / self.volumeSlider.max;
                self.volumeStyle.textContent = '.volume::-webkit-slider-runnable-track{background-size:'+ perc +'% 100%} ';
                self.volumeStyle.textContent += '.volume::-moz-range-track{background-size:'+ perc +'% 100%} ';
            }
          });
      this.addEventListener("playSpeedSelected", function(e) {
            self.playback(e.detail.playbackValue, e.detail.playbackText);
          });
      this.addEventListener("ontagsubmitted", function(e) {
              var arr = [];
              arr.push(e.detail.tagid);
              this.addTagsToRegion(arr);
              this.emitRegionToHost();//Persist
              selected_region = this.selectedRegionId
              this.showAllRegions();
              this.regionSelected(selected_region)
          });
      this.addEventListener("ontagdeleted", function(e) {
              var regionId = this.selectedRegionId -1;//Revert to zero-based array
              var region = this.frames[this.getCurrentFrame()][regionId];
              for(var index = 0;index < region.tags.length;index++){
                    if(region.tags[index] === e.detail.tagid){
                        region.tags.splice(index, 1);
                        break;
                    }
              }
              this.emitRegionToHost();
              selected_region = this.selectedRegionId
              this.showAllRegions();
              this.regionSelected(selected_region)
          });
    },

    //snapToAspectRatio: function()
    //{
        // -5 accounts for rounding errors during rendering to ensure
        // we never redraw larger than the parent container.
        // We need to offset for the non-scaling parts of the video controls
        /* this.snapWidth =
            ($('#video-tagging').parent().height() -
             $('#videoControls').innerHeight() -
             $('#videoTagControls').innerHeight() -
             5) * this.aspect;
        if(this.snapWidth > $('#video-tagging').parent().width()) {
            $('#video-tagging').width($('#video-tagging').parent().width());
        }
        else {
            $('#video-tagging').width(this.snapWidth);
        } */
    //},
    
    /**
       * JQuery Area selector
       * Based on JQuery plugin imgareaselect
       * http://odyniec.net/projects/imgareaselect/usage.html
       *
       * Allows selection of a rectangle
       */
    clearArea: function()
    {
        /*
        $('canvas#overlay').imgAreaSelect({
                  show:false,
                  hide:true
            });
            */
    },
    enableAreaSelect: function(self) {
        /*
      $('canvas#overlay').imgAreaSelect({
            disable: true,
            show:false,
            hide:true
      });
      
      if((this.regiontype.toLowerCase() === "square") || (this.regiontype.toLowerCase() === "rectangle")) {
          $('canvas#overlay').imgAreaSelect({
                        disable: false, //enable/disable
                        handles: true, //grab handles when selecting the area
                        aspectRatio: '1:1',
                        maxWidth: self.overlay.offsetWidth,
                        maxHeight: self.overlay.offsetHeight,
                        minWidth:10,
                        fadeSpeed: 200,
                        square: (this.regiontype.toLowerCase() === "square"),
                        onSelectEnd: function(img, selection){
                              if (selection.width !== 0 && selection.height !== 0) {
                                self.areaSelected = true;
                                self.createRegion(selection.x1, selection.y1, selection.x2, selection.y2);
                                self.clearArea();
                              }
                         },
                         onSelectStart: function(img, selection){
                              self.cleanSelectedElements();
                         },
                      });
          }
          */
    },
    /**
       * All functions related to regions management
       *
       * @method positionRegionNameLabel
       * Positions the div with the region number next to the region div.
       * @param {div} The region div
       */
    //Regions management
    updateRegionZIndices: function(){
        $('.regionCanvas').sort(function (e1, e2) {
            return ($(e1).width() * $(e1).height() <= $(e2).width() * $(e2).height());
        }).each(function(idx,e) {
            e.style.zIndex =(idx+200).toString();
            $(e).css('box-shadow', 'inset 0 0 0 2px ' + $(e).css('border-color')); 
        });
    },
    positionRegionNameLabel: function(div) {
        if (div){
            this.regionLabelDiv.style.left = (div.offsetLeft + parseFloat(div.style.width, 10) - parseFloat(this.regionLabelDiv.style.width, 10)) + "px";
            this.regionLabelDiv.style.top = (div.offsetTop - parseFloat(this.regionLabelDiv.style.height, 10)) + "px" ;
            //Out of bounds top - move it below div
            if(parseFloat(this.regionLabelDiv.style.top) < 0) {
                this.regionLabelDiv.style.top = (div.offsetTop + parseFloat(div.style.height, 10)) + "px" ;
            }
            this.regionLabelSpan.innerHTML = div.id;
            this.regionLabelDiv.style.display = "block";
        }
    },

    onNewAreaSelected: function(x1, y1, x2, y2){
        var threshold = 20;
        var dx, dy;
        var r = {};
        if (x1 < x2) {
            r.x1 = x1;
            r.x2 = x2;
        } else {
            r.x1 = x2;
            r.x2 = x1;
        }

        if (y1 < y2) {
            r.y1 = y1;
            r.y2 = y2;
        } else {
            r.y1 = y2;
            r.y2 = y1;
        }

        dx = Math.abs(x1-x2);
        if (dx < threshold) {
            dx = (threshold - dx)/2
            r.x1 = Math.max(0, r.x1 - dx);
            r.x2 = Math.min(this.frameWidth, r.x2 + dx);
        }

        dy = Math.abs(y1-y2);
        if (dy < threshold) {
            dy = (threshold - dy)/2
            r.y1 = Math.max(0, r.y1 - dy);
            r.y2 = Math.min(this.frameHeight, r.y2 + dy);
        }

        this.createRegion(r.x1, r.y1, r.x2, r.y2);
    },

    createRegion: function(x1, y1, x2, y2) {
        var region = this.addRegion(x1, y1, x2, y2);//Add to in-memory collection
        var xOffset = parseFloat(this.overlay.style.left);
        var yOffset = parseFloat(this.overlay.style.top);
        this.addDivToRegion(x1 + (isNaN(xOffset) ? 0 : xOffset), y1 + (isNaN(yOffset) ? 0 : yOffset), 
                            x2 + (isNaN(xOffset) ? 0 : xOffset), y2 + (isNaN(yOffset) ? 0 : yOffset), 
                            region.name, region.tags); //add frame
        this.updateRegionZIndices();//update region z indecies
        this.regionSelected(region.name);//Select it by default
        //if there is only one tag enable it  by default
        if ($(`#${this.optionalTags.id}`).find('.tagButtons').size() == 1){
            $(`#${this.optionalTags.id}`).find('.tagButtons')[0].click();
        }
        if(this.lockTagsEnabled) {
            //Get all selected tags and add them to current region automatically
            //this.selectedTags was populated in this.lockTagsClicked
            var arr = [];
            for (var i=0; i<this.selectedTags.length;i++) {
              this.optionalTags.setSelected(this.selectedTags[i]);
              arr.push(this.selectedTags[i].id);
            }
            this.addTagsToRegion(arr);
            var self = this;
            //Auto step functionality - Goes to next frame automatically
            if(this.multiregions === "0") {
                  setTimeout(function(){ self.stepFwdClicked(); }, 500);
            }
        }
        this.emitRegionToHost();//Persist
    },
    addTagsToRegion: function(selectedTagsArray) {
          var regionId = this.selectedRegionId -1;//Revert to zero-based array
          var region = this.frames[this.getCurrentFrame()][regionId];
          for (var i = 0; i < selectedTagsArray.length; i++) {
               region.tags.push(selectedTagsArray[i]);
          }
    },
    nextUntaggedClicked:function() {
        if (this.checkRegionLabels()){
          var frameIndex = this.getCurrentFrame();
            if (this.imagelist){//image handling
                var lastTagIndex = parseInt(Object.keys(this.frames)[Object.keys(this.frames).length-1])
                if (this.imageIndex < this.imagelist.length) {
                    if (lastTagIndex <= frameIndex){
                        this.imageIndex++;
                    } else {
                        this.imageIndex = lastTagIndex;
                    }
                    this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
                    this.playingCallback();
                }
            } else { //video handling
                var lastTagIndex = Object.keys(document.getElementById("video-tagging").frames).length;
                var nextFrameOffset = Math.max((lastTagIndex - frameIndex), 1);
                if(!this.video.paused) this.pauseState();
                if ((this.video.currentTime + this.frameTime) > this.video.duration ){
                    return;
                }
                if (!this.canMove ) return; 
                //if there are no unlabled tags move to next frame
                this.video.currentTime += this.frameTime * (nextFrameOffset);
                this.playingCallback();            
            }
        }
    },
    lockTagsClicked: function() {
        var selTags = this.optionalTags.getSelectedTags();
        //There has to be selected label/s
        if (!this.lockTagsEnabled && selTags.length > 0) {
            this.lockTagsEnabled = true;
            this.selectedTags = selTags;
            if(this.multiregions === "0"){this.stepFwdClicked();}
        }
        else {
            this.lockTagsEnabled = false;
            this.selectedTags = [];
            this.optionalTags.resetSelected();
        }
        this.lockTag.classList.toggle("controlOn", this.lockTagsEnabled);
        this.lockTag.classList.toggle("controlOff", !this.lockTagsEnabled);
    },
    regionSelected: function(divId) {
              this.cleanSelectedElements();
              var div = document.getElementById(divId);
              div.classList.add("regionCanvasSelected");
              this.selectedRegionId = div.id;
              this.positionRegionNameLabel(div);
              //Tags - display the tags of the region and enable editing
              this.optionalTags.toggleEnableButtons(true);
              this.optionalTags.resetSelected();
              var regions = this.frames[this.getCurrentFrame()];
              if(regions) {
                  var tags = this.frames[this.getCurrentFrame()][this.selectedRegionId - 1].tags;
                  this.optionalTags.displaySelectedTags(tags);
              }
             function updateRegionFromDiv(div, xOffset, yOffset){
                 var region = regions[(divId-1).toString()];
                 region.width = parseFloat(this.overlay.width);//$('#vid').width();
                 region.height = parseFloat(this.overlay.height);//$('#vid').height();
                 region.x1 = parseInt(div.style.left) - ((xOffset) ? xOffset : 0);
                 region.y1 = parseInt(div.style.top)  - ((yOffset) ? yOffset : 0) ;
                 region.x2 = region.x1 + parseInt(div.style.width);
                 region.y2 = region.y1 + parseInt(div.style.height);
             }
              //make region  draggable
              $('#'+divId).draggable({
                  start: function(event, ui) {
                    self.areaSelector.disable();
                  },
                  stop: function(event, ui) {
                     updateRegionFromDiv(this,parseFloat(self.overlay.style.left), parseFloat(self.overlay.style.top));
                     self.areaSelector.enable();
                  },
                  containment: $("#frameCanvas")[0]
              });

              //make region resizable
               var self = this;
               $('#'+divId).resizable({
                    start: function(event, ui) {
                        self.areaSelector.disable();
                    },
                   stop: function(event, ui) {
                       $('.regionCanvas').sort(function (e1, e2) {
                         return ($(e1).width() * $(e1).height() <= $(e2).width() * $(e2).height());
                       }).each(function(idx,e) {
                         e.style.zIndex =(idx+200).toString();
                       });
                       self.areaSelector.enable();
                   },
                   containment: $("#frameCanvas")[0],
                   handles: 'all'
              });
              $('#'+divId).on('resize',function(e){
                  updateRegionFromDiv(this,parseFloat(self.overlay.style.left), parseFloat(self.overlay.style.top));
                  e.stopPropagation();
              });
              //raise regionSelectedEvent
             $('#video-tagging').trigger('canvasRegionSelected',[divId]); 
    },
    deleteRegion: function(e) {
          var regions = this.frames[this.getCurrentFrame()];
          var deletedRegion = regions[this.selectedRegionId - 1];
          regions.splice(this.selectedRegionId - 1, 1);
          //Shift array left to cover removed item - Rename all regions which are higher than the deleted one,
          for (var i=0;i<regions.length;i++) {
              var id = Number(regions[i].name);
              if(id > this.selectedRegionId){
                  regions[i].name = id - 1;
              }
          }
          this.showAllRegions();
          this.emitRegionToHost();
    },
    clearRegions: function(e) {
          this.frames[this.getCurrentFrame()]=[];
          this.showAllRegions();
          this.emitRegionToHost();
    },
    /**
       * @method emitRegionToHost
       * Fires an event to send the array of regions.
       * The host html page can listen to this event.
       */
    emitRegionToHost: function() {
          var frameIndex = this.getCurrentFrame();
          this.fire('onregionchanged', {frame: {frameIndex:frameIndex, regions:this.frames[frameIndex]}});
    },
    /**
       * @method addDivToRegion
       * Adds a transparent div to the region, the size of the region.
       * Used for click events, hover, etc..
       * @params {x1, y1, x2, y2} region coordinates.
       * @param {regionId} The region id, which is the region index + 1.
       */
    addDivToRegion: function(x1, y1, x2, y2, regionId, tags) {
            var div = document.createElement("div");
            div.id = regionId;
            div.classList.add("regionCanvas");

            if (tags.length > 0){
                div.style.borderColor = this.optionalTags.colors[this.inputtagsarray.indexOf(tags[0])];
            }else {
                div.style.borderColor = null;
            }
            if(this.regiontype.toLowerCase() === "point") {
                  div.style.width = this.regionsize - 1 +  "px";//Compensate for 1px border
                  div.style.height = this.regionsize - 1 +  "px";
                  div.style.top = y1 - this.regionsize/2  +  "px";
                  div.style.left = x1 - this.regionsize/2  +  "px";
                  div.classList.add("regionPoint");
            }
            if((this.regiontype.toLowerCase() === "square") || (this.regiontype.toLowerCase() === "rectangle")) {
                 // add offset here
                  div.style.width = x2 - x1 + "px";
                  div.style.height = y2 - y1   +  "px";
                  div.style.top = y1  + "px";
                  div.style.left = x1 + "px";
            }
            var self = this;
            $( div )
                      .click(function(e) {
                         self.regionSelected(div.id);
                      });
            $( div )
                      .mouseenter(function(e) {
                          self.positionRegionNameLabel(this);
                      })
                      .mouseleave(function() {
                        self.regionLabelDiv.style.display = "none";
                        if(self.selectedRegionId === div.id) {
                              self.regionLabelDiv.style.display = "block";
                        }

                        self.freezeAreaSelection = false;
                      })
                      .mousemove(function(e){
                         self.freezeAreaSelection = true;
                      });
            Polymer.dom(this.$.videoWrapper).appendChild(div);
    },
    /**
       * @method cleanSelectedElements
       * Removes all borders of regions and disables label buttons
       */
    cleanSelectedElements: function() {
          //Remove selected style
          var regionCanvases = Polymer.dom(this.root).querySelectorAll('.regionCanvas');
          for (var i=0;i<regionCanvases.length;i++) {
            regionCanvases[i].classList.remove('regionCanvasSelected');
          }
          //reset
          this.selectedRegionId = 0;
          this.optionalTags.toggleEnableButtons(false);
          this.optionalTags.resetSelected();
    },
    showAllRegions: function() {
            this.clearFrameElements();//Clear canvas and tags
            this.cleanSelectedElements();//Clear selected regions
            var frameIndex = this.getCurrentFrame();
            var regions = this.frames[frameIndex];
            if(regions && regions.length > 0) {
              //Draw all regions for this frame
              for (var i=0; i<regions.length;i++) {
                  var region = regions[i];
                  //Frame was tagged as empty?
                  if (Object.keys(region).length === 0) {
                      this.indicateEmptyFrame(true);
                      continue;
                  }
                  //Calculate x, y relative to current width and height
                  //if (this.imagelist){
                     var widthRatio = this.overlay.width / region.width;
                     var heightRatio = this.overlay.height / region.height ;
                  //} else {
                  //   var widthRatio = $("#vid").width() / region.width;
                  //   var heightRatio = $("#vid").height() / region.height ;
                  //}
                  var x1 = (region.x1 * widthRatio);
                  var y1 = (region.y1 * heightRatio);
                  var x2 = (region.x2 * widthRatio);
                  var y2 = (region.y2 * heightRatio);
                  x1 = (region.x1 * widthRatio);
                  y1 = (region.y1 * heightRatio);
                  x2 = (region.x2 * widthRatio);
                  y2 = (region.y2 * heightRatio);
                  var xOffset = parseFloat(this.overlay.style.left);
                  var yOffset = parseFloat(this.overlay.style.top);

                  this.addDivToRegion(x1 + (isNaN(xOffset) ? 0 : xOffset), y1 + (isNaN(yOffset) ? 0 : yOffset), 
                                      x2 + (isNaN(xOffset) ? 0 : xOffset), y2 + (isNaN(yOffset) ? 0 : yOffset), 
                                      region.name, region.tags); //add frame
                  //Only 1 region - select it and show tags
                  if (regions.length === 1) {
                      this.regionSelected(region.name);
                  }
                  this.updateRegionZIndices();
              }
            }
    },
    
    /**
       * @method addRegion
       * Adds a region to the array of regions per current frame.
       * @params {x1, y1, x2, y2} region coordinates.
       */
    addRegion: function(x1, y1, x2, y2) {
            this.resetEmptyFrame();//Clear empty frame logic
            var region = {};
            region.x1 = x1;
            region.y1 = y1;
            region.x2 = x2;
            region.y2 = y2;
            region.id = this.uniqueTagId++;
            region.width = parseFloat(this.overlay.width); //ensures pass by value
            region.height = $('#vid').height();
            region.type = this.regiontype;
            region.tags = [];
            var frameIndex = this.getCurrentFrame();
            var regions = this.frames[frameIndex];
            //The array is populated and can contain multiple regions
            if(this.multiregions == 1 && regions) {
                region.name = regions.length + 1;
                this.frames[frameIndex].push(region);
            }
            else {//Only one region allowed
                this.clearFrameElements();
                region.name = 1;
                this.frames[frameIndex] = [];
                this.frames[frameIndex].push(region);
            }
            return region;
    },
    /**
       * All functions related to frames management
       *
       * @method clearFrameElements
       * Clears all drawings and divs from the video area and resets tag controls.
       */
    clearFrameElements: function() {
      //Clear divs
      $(this.videoWrapper).children(".regionCanvas").remove();
      //reset tag buttons to not selected
      this.optionalTags.resetSelected();
      //hide region number
      this.regionLabelDiv.style.display = "none";
      //Clears the empty frame icon
      this.indicateEmptyFrame(false);
    },
    getCurrentFrame: function() {
      if (this.imagelist){
        return this.imageIndex;
      } 
      return this.video.currentTime === 0 ? 1 : Math.ceil((this.video.currentTime - this.videoStartTime) * this.framerate) + 1 ;
    },
    indicateEmptyFrame : function(selected) {
        if(selected) {
            this.emptyFrame.classList.remove("controlOff");
            this.emptyFrame.classList.add("controlOn");
        }
        else {
            this.emptyFrame.classList.remove("controlOn");
            this.emptyFrame.classList.add("controlOff");
        }
    },
    /**
       * @method emptyFrameClicked
       * Creates an empty region array for the current frame, meaning that the frame is not tagged, but has been reviewed.
       */
    emptyFrameClicked: function() {
        var frameIndex = this.getCurrentFrame();
        var regions = this.frames[frameIndex];
        if(!regions || regions.length === 0) {
            this.frames[frameIndex] = [{}];
            this.indicateEmptyFrame(true);
            this.emitRegionToHost();
            if(this.lockTagsEnabled){
                this.stepFwdClicked();
            }
        }
    },
    /**
       * @method resetEmptyFrame
       * If the frame has been marked as empty - reset that.
       */
    resetEmptyFrame: function() {
        var regions = this.frames[this.getCurrentFrame()];
        //If there is an empty region
        if(regions && regions.length === 1 && Object.keys(regions[0]).length === 0) {
            //reset all for this frame
            this.frames[this.getCurrentFrame()] = [];
            this.clearFrameElements();
        }
    },
    /**
       * Video management
       *
       */
    muteClicked: function() {
          this.mute.classList.toggle("icon-volume-mute2", !this.video.muted);
          this.mute.classList.toggle("icon-volume-medium", this.video.muted);
          this.video.muted = !this.video.muted;
    },
    /**
       * Handler for setting the video play speed
       */
    playback: function(val, text) {
          if(val !== null){
              this.video.playbackRate = val;
              this.playbackSpan.innerHTML = text;
          }
          this.playSpeedControl.style.display = "none";
    },
    /**
       * Shows the play speed control
       */
    playbackSpeedClicked: function() {
          var offset = $('#playSpeedCell').offset();
          var top = offset.top - $('#playSpeedControl').height();
          var left = offset.left + $('#playSpeedCell').width() / 4;
          $('#playSpeedControl').css({'left': left, 'top': top});
          this.playSpeedControl.style.display = this.playSpeedControl.style.display === "block"?"none":"block";
    },
    playPauseClicked: function() {
          this.video.paused ? this.playState():this.pauseState();
    },
    getUnlabeledRegionTags: function(regionId){
         var regions = this.frames[regionId];
         var unlabledTags = [];
         if (regions !== undefined){
            unlabledTags = regions.map(function(region,index){
                if (!region.tags.length > 0) return index + 1;
         }).filter(Number.isInteger);
        }
        return unlabledTags;
    },
    checkRegionLabels: function(){
        var unlabledTags = this.getUnlabeledRegionTags(this.getCurrentFrame());
        if (unlabledTags.length > 0){
            alert(`Cannot move to the next frame until all tags are labeled. Please label the following tags [${unlabledTags}] on the displayed frame.`);
            return false;
        }
        return true;
    },
    //used for init of image directory find way to reduce duplicate code
    initImageDir: function() {
        if (!this.imagelist) return;
        //$("#rotate").show();
        this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
        var self = this;
        self.frames = self.inputframes? self.inputframes:{};
        self.optionalTags.createTagControls(self.inputtagsarray);

        //self.resetLayout();
        
        //bind keys (note this currently overrides any listener on the parent controls needs a more elegant way to work only when control is in focus)
        window.addEventListener("keyup", (function(canMove) {
            return function(e) {
                if (!canMove) return false;
                canMove = false;
                setTimeout(function() { canMove = true; }, 100);
                switch (e.keyCode) {
                    case 37:  // left
                    self.stepBwdClicked();
                    break;
                    case 39: // right
                    self.stepFwdClicked();
                    break;
                    case 9: //tab
                    if (self.selectedRegionId){
                        if (self.selectedRegionId >= self.frames[self.getCurrentFrame()].length){
                            self.regionSelected(0)
                        }
                        // self.selectedRegionId += 1
                        self.regionSelected(parseInt(self.selectedRegionId)+1)
                    } else{
                        self.regionSelected(0)
                    }          
                    break;
                    case 68:// d for duplicate
                    if (self.imageIndex > 0){
                        self.frames[self.imageIndex] = JSON.parse(JSON.stringify(self.frames[self.imageIndex-1]));
                    }
                    self.playingCallback();
                    break;
                    case 46: //delete
                    case 8:  //backspace
                    if($('.regionCanvasSelected')[0]){
                        self.deleteRegion();
                    }
                    break;
                    default: return; // exit this handler for other keys
                }
                e.preventDefault(); // prevent the default action (scroll / move caret)
            };
        })(true), false);        
    },
    changeImage: function(imageUrl){
        this.rotation = 0;
        this.video.style.backgroundImage = encodeURI(imageUrl);
        this.curImg.src = `${this.imagelist[this.imageIndex]}`;
        var self = this;

        self.curImg.onload = function() {
            self.controlWrapper.style.display = "grid";
            self.aspect = self.curImg.width / self.curImg.height;;
            //Size canvas as image
            let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
            
            self.resizeFrame(scaleByPortrait, self.aspect);

            //Init variables and controls
            self.enableAreaSelect(self);
            self.playingCallback();

            //fix resize bug
            $(window).off("resize");
            $(window).resize(function(){
                if (self.video.offsetWidth !== undefined){
                    //self.snapToAspectRatio();

                    let scaleByPortrait = ((videotagging.video.offsetWidth/videotagging.video.offsetHeight) >= self.aspect);
                    self.resizeFrame(scaleByPortrait, self.aspect);
                    
                    //resize the region boxes
                    self.showAllRegions();
                    //reposition selectedRegion Label
                    var selectedDiv = $('.regionCanvasSelected')[0];
                    self.positionRegionNameLabel(selectedDiv);

                    self.playingCallback();
                }
            });
        }

    },

    resizeFrame(isPortrait, imgRatio) {
        if (isPortrait) {
            this.resizeFrameSize(parseFloat(this.video.offsetHeight * imgRatio), this.video.offsetHeight);
            //shift the overlay
            var leftShift = `${((this.video.offsetWidth/2) - (this.overlay.width/2))}px`;
            this.overlay.style.left = leftShift;
            this.overlay.style.top  = '0px';

            this.frameCanvas.style.margin = "0px " + leftShift; 
            this.selectionZone.style.margin = "0px " + leftShift;  

        } else {
            this.resizeFrameSize(this.video.offsetWidth, parseFloat(this.video.offsetWidth / imgRatio));
            //shift the overlay
            var topShift = `${((this.video.offsetHeight/2) - (this.overlay.height/2))}px`
            this.overlay.style.top = topShift;
            this.overlay.style.left  = '0px';

            this.frameCanvas.style.margin = topShift + " 0px"; 
            this.selectionZone.style.margin = topShift + " 0px"; 
        }
    },

    resizeFrameSize: function(width, height) {
        this.frameWidth = width;
        this.frameHeight = height;

        this.overlay.width = this.frameWidth;
        this.overlay.height = this.frameHeight;
                        
        this.frameCanvas.width = this.frameWidth;
        this.frameCanvas.height = this.frameHeight;

        this.areaSelector.resize(width, height);
    },

    resetLayout: function(){
        this.overlay.style.top = "";
        this.overlay.style.left = "";
        this.frameCanvas.style.margin = "";
        this.selectionZone.style.margin = "";
    },

    disableImageDir: function() {       
        $("#rotate").hide(); 
        $(window).off("resize");
        this.imageIndex = 0;
        this.imagelist = undefined;
        this.video.removeAttribute("poster");
        this.src = "";
    },

    rotate: function() {
        this.rotation = (this.rotation + 90) % 360;
        $('#vid').css("transform",`rotate(${this.rotation}deg)`);   
    },
    stepFwdClicked: function(fireEvents = true) {       
        if (this.checkRegionLabels()){
            //raise before next frame  
            if (this.imagelist){//image handling
                if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-BeforeStep');    
                if (this.imageIndex < this.imagelist.length-1) {
                    this.imageIndex++;
                    this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
                    this.playingCallback();
                }
            } else { //video handling
                if(!this.video.paused) this.pauseState();
                if ((this.video.currentTime + this.frameTime) > this.video.duration ){
                    //this.video.currentTime = this.video.duration;
                    return;
                }
                if (!this.canMove ) return; 
                if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-BeforeStep');    
                //if there are no unlabled tags move to next frame
                this.video.currentTime += this.frameTime;
                this.playingCallback();            
            } 
            //raise after next frame
            if(fireEvents)$('#video-tagging').trigger('stepFwdClicked-AfterStep');

        }
    },
    stepBwdClicked: function(fireEvents = true) {
        if (!this.canMove) return;    
        if (this.imagelist){//image handling
            if (this.imageIndex > 0) {
                this.imageIndex--;
                this.changeImage(`url(file://${this.imagelist[this.imageIndex].replace(/\\/g,"/")})`);
                this.playingCallback();
            }
        } 
        if (this.video.currentTime > 0) {
            if(!this.video.paused) {
              this.pauseState();
            }
            if (this.checkRegionLabels()){
              this.video.currentTime -= this.frameTime;
              this.playingCallback();
            }
        }
        if(fireEvents)$('#video-tagging').trigger('stepBwdClicked-AfterStep');    
    },
    videoSrcChanged: function(newValue, oldValue) {
          if(this.video){
             if (this.imagelist){
                this.initImageDir();
             } else{
                this.video.src = newValue;
                this.video.style.backgroundImage = null;
             }
          }
    },
    videoClicked: function(e) {
            this.cleanSelectedElements();
            if(!((this.regiontype.toLowerCase() === "square") || (this.regiontype.toLowerCase() === "rectangle")))
            {
                var rect = this.overlay.getBoundingClientRect();
                var x1 = (e.clientX-rect.left)/(rect.right-rect.left)*this.overlay.width;
                var y1 = (e.clientY-rect.top)/(rect.bottom-rect.top)*this.overlay.height;
                this.createRegion(x1, y1, null, null);
            }
    },
    playState: function() {
        this.video.play();
        this.playButton.classList.toggle("icon-pause2", !this.video.paused);
        //Reset lock tags to off
        this.lockTagsEnabled = true;
        this.lockTagsClicked();
        this.optionalTags.toggleEnableButtons(false);
        // $('canvas#overlay').imgAreaSelect({disable: true});//disable canvas
        var self = this;
        this.playing = setInterval(function() {
            self.playingCallback();
        }, 10);
    },
    pauseState: function() {
            this.video.pause();
            clearInterval(this.playing);
            this.video.currentTime =  Math.floor(this.video.currentTime/this.frameTime) * this.frameTime;//keep the frame in sync
            this.playingCallback();
            this.playButton.classList.toggle("icon-pause2", !this.video.paused);
            this.optionalTags.toggleEnableButtons(false);
            // $('canvas#overlay').imgAreaSelect({disable: false});//enable canvas
    },
    playingCallback: function() {
            if (!this.imagelist){
                this.frameText.innerHTML = this.getCurrentFrame();
                this.displayVideoTime();
                if(!this.seeking){
                    this.updateSeekBar();
                }

                // Update canvas image based on new video frame
                this.updateFrameCanvas(this.video);

            } else{
                this.frameText.innerHTML = `${this.getCurrentFrame() + 1}/${this.imagelist.length}`;
                
                // Update canvas image based on new video frame
                this.updateFrameCanvas(this.curImg);
            }
                        
            this.showAllRegions();
    },
    displayVideoTime: function() {
            var currentTime = Math.round(this.video.currentTime);
            var remainingtTime = Math.round(this.video.duration - this.video.currentTime);
            //Format using moment.js
            currentTime = moment().startOf('day').seconds(currentTime).format('HH:mm:ss');
            remainingtTime = moment().startOf('day').seconds(remainingtTime).format('HH:mm:ss');
            this.timeSpan.innerHTML = currentTime + "  /  " + remainingtTime;
    },
    updateSeekBar: function() {
            this.seekBar.value = this.video.currentTime;
            var perc =  100 * this.seekBar.value / this.seekBar.max;
            this.seekStyle.textContent =  '.seek::-webkit-slider-runnable-track{background-size:'+perc+'% 100%}';
            this.seekStyle.textContent += '.seek::-moz-range-track{background-size:'+perc+'% 100%}';
    },
    updateFrameCanvas: function(source) {
        var context = this.frameCanvas.getContext('2d');
        var self = this;
        if (source instanceof HTMLVideoElement) {
            source.addEventListener('canplaythrough', function () {
                window.requestAnimationFrame(function(){
                    context.drawImage(source, 0, 0, self.frameWidth, self.frameHeight);
                });
            });
        } else if (source instanceof HTMLImageElement) {
            window.requestAnimationFrame(function(){
                    context.drawImage(source, 0, 0, self.frameWidth, self.frameHeight);
            });
        }
    },


    // Image filters for frameCanvas (not exposed to interface yet!)
    applyFilter(filter) {
        var canvas = this.frameCanvas;
        var context = canvas.getContext('2d');
        var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        imageData = filter(imageData);

        window.requestAnimationFrame(function(){
            context.putImageData(imageData, 0 ,0);
        });
    },

    invertFilter(imageData) {
        var data = imageData.data;
        for(var i=0;i<data.length;i+=4)
        {
            data[i]     = 255 - data[i];     // red
            data[i + 1] = 255 - data[i + 1]; // green
            data[i + 2] = 255 - data[i + 2]; // blue
        }

        return imageData;
    },

    contrastFilter(imageData, contrast) {
        var data = imageData.data;
        var factor = (259 * (contrast + 255)) / (255 * (259 - contrast));

        for(var i=0;i<data.length;i+=4)
        {
            data[i] = factor * (data[i] - 128) + 128;
            data[i+1] = factor * (data[i+1] - 128) + 128;
            data[i+2] = factor * (data[i+2] - 128) + 128;
        }

        return imageData;
    },

    convoluteFilter(imageData, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = imageData.data;
        var sw = imageData.width;
        var sh = imageData.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var output = new ImageData(w, h);

        var dst = output.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y*w+x)*4;
                // calculate the weighed sum of the source image pixels that
                // fall under the convolution matrix
                var r=0, g=0, b=0, a=0;
                for (var cy=0; cy<side; cy++) {
                    for (var cx=0; cx<side; cx++) {
                        var scy = sy + cy - halfSide;
                        var scx = sx + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = (scy*sw+scx)*4;
                            var wt = weights[cy*side+cx];
                            r += src[srcOff] * wt;
                            g += src[srcOff+1] * wt;
                            b += src[srcOff+2] * wt;
                            a += src[srcOff+3] * wt;
                        }
                    }
                }
                dst[dstOff] = r;
                dst[dstOff+1] = g;
                dst[dstOff+2] = b;
                dst[dstOff+3] = a + alphaFac*(255-a);
            }
        }
        return output;
    }

});
</script>
<script src="../jquery/dist/jquery.min.js"></script>
<script src="../moment/moment.js"></script>
<script src="js/jquery.imgareaselect.js"></script>
<script src="../jquery-ui/jquery-ui.min.js"></script>
<script src="js/system.js"></script>
</dom-module>